#include <stdio.h>
int h[ 101];//用来存放堆的数组
int n;//用来存储堆中元素的个数，也就是堆的大小


//交换函数，用来交换堆中的两个元素的值
void swap(int x,int y)
{
    int t;
    t=h[ x];
    h[ x]=h[ y];
    h[ y]=t;
}


//向下调整函数
void siftdown(int i) //传入一个需要向下调整的结点编号i，这里传入1，即从堆的顶点开始向下调整
{
    int t,flag=0;//flag用来标记是否需要继续向下调整
    //当i结点有儿子的时候（其实是至少有左儿子的情况下）并且有需要继续调整的时候循环窒执行
    while( i*2<=n && flag==0 )
    {        
        //首先判断他和他左儿子的关系，并用t记录值较小的结点编号
        if( h[i] > h[i*2] )
            t=i*2;
        else
            t=i;
        //如果他有右儿子的情况下，再对右儿子进行讨论
        if(i*2+1 <= n)
        {
            //如果右儿子的值更小，更新较小的结点编号  
            if(h[t] > h[ i*2+1])
                t=i*2+1;
        }
        //这两个if判断已经记录下来当前父节点和两个子节点中最小的一个，并将它作为父节点，此时它肯定小于两个子节点；
        //为了满足最小堆的要求，此时只要将换下来的那个新子节点再和它的儿子做比较就可以了。

        //如果发现最小的结点编号不是自己，说明子结点中有比父结点更小的  
        if(t!=i)
        {
            swap(t,i);//交换它们，注意swap函数需要自己来写
            i=t;//更新i为刚才与它交换的儿子结点的编号，便于接下来继续向下调整
        }
        else
            flag=1;//则否说明当前的父结点已经比两个子结点都要小了，不需要在进行调整了
    }
}


//建立堆的函数
void creat()
{
    int i;
    //从最后一个非叶结点到第1个结点依次进行向上调整
    for(i=n/2;i>=1;i--)
    {
        siftdown(i);
    }  
}


//删除最大的元素
int deletemax()
{
    int t;
    t=h[1];//用一个临时变量记录堆顶点的值
    printf("the top is %d\n",t );
    h[1]=h[ n];//将堆得最后一个点赋值到堆顶
    n--;//堆的元素减少1
    siftdown(1);//向下调整
    return t;//返回之前记录的堆得顶点的最小值，注意，此处书上有误，这里的最小堆，不断输出最顶端数字，是按照从小到大的顺序。
}
//建立最小堆，然后进行排序输出按从小到大。

int main()
{
    int i,num;
    //读入数的个数
    scanf("%d",&num);


    for(i=1;i<=num;i++)
        scanf("%d",&h[i]);
    n=num;   

    //建堆
    creat();

    //删除顶部元素，连续删除n次，其实也就是从大到小把数输出来
    for(i=1;i<=num;i++)
        //printf("%d\n",h[i]);//这里这样会出错，因为只保证了子节点都小于父节点，而子节点之间没有排序
        printf("%d ",deletemax());

    getchar();
    getchar();
    return 0;
}
